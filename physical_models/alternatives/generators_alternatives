

def generator_noise_reduction_net(batch_size, track_length, track_time, diffusion_model_state):
    assert (diffusion_model_state == 0 or diffusion_model_state == 1), "State must be 0 or 1"

    while True:
        t_sample = np.random.choice(np.linspace(track_time * 0.85, track_time * 1.15, 50))
        out = np.zeros(shape=[batch_size, track_length, 1])
        label = np.zeros(shape=[batch_size, track_length])

        for i in range(batch_size):

            two_state_model = TwoStateDiffusion.create_random()
            if diffusion_model_state == 0:
                x_noisy, y_noisy, x, y, t = two_state_model.simulate_track_only_state0(track_length=track_length,
                                                                                       track_time=t_sample)

            else:
                x_noisy, y_noisy, x, y, t = two_state_model.simulate_track_only_state1(track_length=track_length,
                                                                                       track_time=t_sample)

            out[i, :, 0] = x_noisy - np.mean(x_noisy)
            label[i, :] = x - np.mean(x_noisy)

        yield out, label




def generator_hurst_exp_network_granik(batch_size, track_length, track_time, fbm_type):
    while True:
        out = np.zeros(shape=(batch_size, track_length - 1, 1))
        label = np.zeros(shape=(batch_size, 1))
        t_sample = np.random.choice(np.linspace(track_time * 0.85, track_time * 1.15, 50))

        for i in range(batch_size):
            if fbm_type == 'subdiffusive':
                model_sample = FBM.create_random_subdiffusive()
            else:
                model_sample = FBM.create_random_superdiffusive()
            x_noisy, y_nosy, x, y, t = model_sample.simulate_track(track_length=track_length, track_time=t_sample)
            label[i, 0] = model_sample.hurst_exp

            dx = np.diff(x_noisy, axis=0)
            out[i, :, 0] = autocorr((dx - np.mean(dx)) / (np.std(dx)))

        yield out, label


def axis_adaptation_to_net_spectrum(axis_data, track_length):
    data_fft = np.fft.fft(axis_data)
    real_component = data_fft.real
    im_component = data_fft.imag
    axis_data_spectrum = np.zeros(shape=(2, track_length))
    axis_data_spectrum[0, :] = real_component[:track_length]
    axis_data_spectrum[1, :] = im_component[:track_length]

    axis_data_spectrum[0, :] = axis_data_spectrum[0, :] - np.mean(axis_data_spectrum[0, :])
    axis_data_spectrum[1, :] = axis_data_spectrum[1, :] - np.mean(axis_data_spectrum[1, :])
    return axis_data_spectrum


def generate_batch_of_samples_l1_spectrum(batch_size, track_length, track_time):
    out = np.zeros(shape=[batch_size, 2, track_length, 2])
    label = np.zeros(shape=[batch_size, 1])
    t_sample = np.random.choice(np.linspace(track_time * 0.85, track_time * 1.15, 50))
    track_length_sample = int(np.random.choice(np.arange(track_length, np.ceil(track_length * 1.05), 1)))

    for i in range(batch_size):
        model_sample = np.random.choice(["fBm", "CTRW", "2-State"])
        if model_sample == "fBm":
            model = FBM.create_random()
            x_noisy, y_noisy, x, y, t = model.simulate_track(track_length=track_length_sample, track_time=t_sample)
            label[i, 0] = 0

        elif model_sample == "CTRW":
            model = CTRW.create_random()
            x_noisy, y_noisy, x, y, t = model.simulate_track(track_length=track_length_sample, track_time=t_sample)
            label[i, 0] = 1

        else:
            model = TwoStateDiffusion.create_random()
            switching = False
            while not switching:
                x_noisy, y_noisy, x, y, t, state, switching = model.simulate_track(track_length=track_length_sample,
                                                                                   track_time=t_sample)
            label[i, 0] = 2

        out[i, :, :, 0] = axis_adaptation_to_net_spectrum(axis_data=x_noisy, track_length=track_length)
        out[i, :, :, 1] = axis_adaptation_to_net_spectrum(axis_data=y_noisy, track_length=track_length)

    return out, label


def generator_first_layer_spectrum(batch_size, track_length, track_time):
    while True:
        out, label = generate_batch_of_samples_l1_spectrum(batch_size=batch_size,
                                                           track_length=track_length,
                                                           track_time=track_time)
        label = to_categorical(y=label, num_classes=3)
        input_net = np.zeros(shape=[batch_size, 2, track_length, 1])

        for i in range(batch_size):
            input_net[i, :, :, 0] = out[i, :, :, 0]

        yield input_net, label


def generate_batch_of_samples_l2_spectrum(batch_size, track_length, track_time):
    out = np.zeros(shape=[batch_size, 2, track_length, 2])
    label = np.zeros(shape=[batch_size, 1])
    t_sample = np.random.choice(np.linspace(track_time * 0.85, track_time * 1.15, 50))
    track_length_sample = int(np.random.choice(np.arange(track_length, np.ceil(track_length * 1.05), 1)))

    for i in range(batch_size):
        model_sample = np.random.choice(["subdiffusive", "brownian", "superdiffusive"])
        if model_sample == "subdiffusive":
            model = FBM.create_random_subdiffusive()
            label[i, 0] = 0

        elif model_sample == "brownian":
            model = FBM.create_random_brownian()
            label[i, 0] = 1

        else:
            model = FBM.create_random_superdiffusive()
            label[i, 0] = 2

        x_noisy, y_noisy, x, y, t = model.simulate_track(track_length=track_length_sample, track_time=t_sample)

        out[i, :, :, 0] = axis_adaptation_to_net_spectrum(axis_data=x_noisy, track_length=track_length)
        out[i, :, :, 1] = axis_adaptation_to_net_spectrum(axis_data=y_noisy, track_length=track_length)

    return out, label


def generator_second_layer_spectrum(batch_size, track_length, track_time):
    while True:
        out, label = generate_batch_of_samples_l2_spectrum(batch_size=batch_size,
                                                           track_length=track_length,
                                                           track_time=track_time)
        label = to_categorical(y=label, num_classes=3)
        input_net = np.zeros(shape=[batch_size, 2, track_length, 1])

        for i in range(batch_size):
            input_net[i, :, :, 0] = out[i, :, :, 0]

        yield input_net, label
